{"allowed_envs":["XORDI_API_KEY","XORDI_API_URL","MIGRATION_TRIGGER_KEY","PROXY_MODE","WIREGUARD_HOST","WIREGUARD_BASE_PORT","WG_PROXY_USER","WG_PROXY_PASS","ENABLE_DEBUG_SCREENSHOTS","DEBUG_SCREENSHOT_TTL_MS","DEBUG_SCREENSHOT_BASE_URL","MIN_POOL_SIZE","DOCKER_NETWORK","NEKO_DESKTOP_SCREEN","NEKO_DESKTOP_SCALING","BROWSER_CPU_LIMIT","BROWSER_MEMORY_LIMIT","BROWSER_MEMORY_RESERVATION","TOKSCOPE_ENCLAVE_IMAGE","TOKSCOPE_BROWSER_MANAGER_IMAGE","TOKSCOPE_BROWSER_IMAGE"],"docker_compose_file":"version: '3.8'\n\n# ============================================================================\n# TOKSCOPE PRODUCTION TEE - Phala Cloud CVM\n# ============================================================================\n# All images referenced via env vars (set in Phala Cloud dashboard).\n# All secrets via ${VAR} interpolation (encrypted secrets in dashboard).\n# No hardcoded credentials or image tags.\n# ============================================================================\n\nservices:\n  tokscope-enclave:\n    image: ${TOKSCOPE_ENCLAVE_IMAGE}\n    container_name: tokscope-enclave\n    hostname: tokscope-enclave\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - PORT=3000\n      - XORDI_API_KEY=${XORDI_API_KEY}\n      - XORDI_API_URL=${XORDI_API_URL}\n      - BROWSER_MANAGER_URL=http://browser-manager:3001\n      - MIGRATION_TRIGGER_KEY=${MIGRATION_TRIGGER_KEY}\n      - PROXY_MODE=${PROXY_MODE}\n      - WIREGUARD_HOST=${WIREGUARD_HOST}\n      - WIREGUARD_BASE_PORT=${WIREGUARD_BASE_PORT}\n      - WG_PROXY_USER=${WG_PROXY_USER}\n      - WG_PROXY_PASS=${WG_PROXY_PASS}\n      - ENABLE_DEBUG_SCREENSHOTS=${ENABLE_DEBUG_SCREENSHOTS}\n      - DEBUG_SCREENSHOT_TTL_MS=${DEBUG_SCREENSHOT_TTL_MS}\n      - DEBUG_SCREENSHOT_BASE_URL=${DEBUG_SCREENSHOT_BASE_URL}\n    volumes:\n      - /var/run/dstack.sock:/var/run/dstack.sock\n    security_opt:\n      - no-new-privileges:true\n    read_only: true\n    tmpfs:\n      - /tmp:size=100M,noexec,nosuid,nodev\n      - /var/tmp:size=100M,noexec,nosuid,nodev\n      - /app/node_modules/.cache:size=50M,noexec,nosuid,nodev\n    networks:\n      - tokscope_default\n    restart: \"no\"\n\n  browser-manager:\n    image: ${TOKSCOPE_BROWSER_MANAGER_IMAGE}\n    pull_policy: always\n    container_name: browser-manager\n    hostname: browser-manager\n    environment:\n      - DOCKER_HOST=unix:///var/run/docker.sock\n      - MIN_POOL_SIZE=${MIN_POOL_SIZE}\n      - DOCKER_NETWORK=${DOCKER_NETWORK}\n      - TCB_BROWSER_IMAGE=${TOKSCOPE_BROWSER_IMAGE}\n      - NEKO_DESKTOP_SCREEN=${NEKO_DESKTOP_SCREEN}\n      - NEKO_DESKTOP_SCALING=${NEKO_DESKTOP_SCALING}\n      - BROWSER_CPU_LIMIT=${BROWSER_CPU_LIMIT}\n      - BROWSER_MEMORY_LIMIT=${BROWSER_MEMORY_LIMIT}\n      - BROWSER_MEMORY_RESERVATION=${BROWSER_MEMORY_RESERVATION}\n      - PROXY_MODE=${PROXY_MODE}\n      - WIREGUARD_HOST=${WIREGUARD_HOST}\n      - WIREGUARD_BASE_PORT=${WIREGUARD_BASE_PORT}\n      - WG_PROXY_USER=${WG_PROXY_USER}\n      - WG_PROXY_PASS=${WG_PROXY_PASS}\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - /var/run/dstack.sock:/var/run/dstack.sock\n    cap_add:\n      - SYS_ADMIN\n    privileged: true\n    tmpfs:\n      - /tmp:size=100M\n      - /var/tmp:size=100M\n    networks:\n      - tokscope_default\n    restart: \"no\"\n\n  browser-image-puller:\n    image: ${TOKSCOPE_BROWSER_IMAGE}\n    pull_policy: always\n    container_name: browser-image-puller\n    command: [\"echo\", \"Browser image pre-pulled successfully\"]\n    networks:\n      - tokscope_default\n    restart: \"no\"\n\nnetworks:\n  tokscope_default:\n    driver: bridge","features":["kms","tproxy-net"],"gateway_enabled":true,"kms_enabled":true,"local_key_provider_enabled":false,"manifest_version":2,"name":"","no_instance_id":false,"pre_launch_script":"#!/bin/bash\necho \"----------------------------------------------\"\necho \"Running Phala Cloud Pre-Launch Script v0.0.12\"\necho \"----------------------------------------------\"\nset -e\n\n# Function: notify host\n\nnotify_host() {\n    if command -v dstack-util >/dev/null 2>&1; then\n        dstack-util notify-host -e \"$1\" -d \"$2\"\n    else\n        tdxctl notify-host -e \"$1\" -d \"$2\"\n    fi\n}\n\nnotify_host_hoot_info() {\n    notify_host \"boot.progress\" \"$1\"\n}\n\nnotify_host_hoot_error() {\n    notify_host \"boot.error\" \"$1\"\n}\n\n# Function: Perform Docker cleanup\nperform_cleanup() {\n    echo \"Pruning unused images\"\n    docker image prune -af\n    echo \"Pruning unused volumes\"\n    docker volume prune -f\n    notify_host_hoot_info \"docker cleanup completed\"\n}\n\n# Function: Check Docker login status without exposing credentials\ncheck_docker_login() {\n    # Try to verify login status without exposing credentials\n    if docker info 2>/dev/null | grep -q \"Username\"; then\n        return 0\n    else\n        return 1\n    fi\n}\n\n# Main logic starts here\necho \"Starting login process...\"\n\n# Check if Docker credentials exist\nif [[ -n \"$DSTACK_DOCKER_USERNAME\" && -n \"$DSTACK_DOCKER_PASSWORD\" ]]; then\n    echo \"Docker credentials found\"\n    \n    # Check if already logged in\n    if check_docker_login; then\n        echo \"Already logged in to Docker registry\"\n    else\n        echo \"Logging in to Docker registry...\"\n        # Login without exposing password in process list\n        if [[ -n \"$DSTACK_DOCKER_REGISTRY\" ]]; then\n            echo \"$DSTACK_DOCKER_PASSWORD\" | docker login -u \"$DSTACK_DOCKER_USERNAME\" --password-stdin \"$DSTACK_DOCKER_REGISTRY\"\n        else\n            echo \"$DSTACK_DOCKER_PASSWORD\" | docker login -u \"$DSTACK_DOCKER_USERNAME\" --password-stdin\n        fi\n        \n        if [ $? -eq 0 ]; then\n            echo \"Docker login successful\"\n        else\n            echo \"Docker login failed\"\n            notify_host_hoot_error \"docker login failed\"\n            exit 1\n        fi\n    fi\n# Check if AWS ECR credentials exist\nelif [[ -n \"$DSTACK_AWS_ACCESS_KEY_ID\" && -n \"$DSTACK_AWS_SECRET_ACCESS_KEY\" && -n \"$DSTACK_AWS_REGION\" && -n \"$DSTACK_AWS_ECR_REGISTRY\" ]]; then\n    echo \"AWS ECR credentials found\"\n    \n    # Check if AWS CLI is installed\n    if [ ! -f \"./aws/dist/aws\" ]; then\n        notify_host_hoot_info \"awscli not installed, installing...\"\n        echo \"AWS CLI not installed, installing...\"\n        curl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64-2.24.14.zip\" -o \"awscliv2.zip\"\n        echo \"6ff031a26df7daebbfa3ccddc9af1450 awscliv2.zip\" | md5sum -c\n        if [ $? -ne 0 ]; then\n            echo \"MD5 checksum failed\"\n            notify_host_hoot_error \"awscli install failed\"\n            exit 1\n        fi\n        unzip awscliv2.zip &> /dev/null\n    else\n        echo \"AWS CLI is already installed: ./aws/dist/aws\"\n    fi\n\n    # Set AWS credentials as environment variables\n    export AWS_ACCESS_KEY_ID=\"$DSTACK_AWS_ACCESS_KEY_ID\"\n    export AWS_SECRET_ACCESS_KEY=\"$DSTACK_AWS_SECRET_ACCESS_KEY\"\n    export AWS_DEFAULT_REGION=\"$DSTACK_AWS_REGION\"\n    \n    # Set session token if provided (for temporary credentials)\n    if [[ -n \"$DSTACK_AWS_SESSION_TOKEN\" ]]; then\n        echo \"AWS session token found, using temporary credentials\"\n        export AWS_SESSION_TOKEN=\"$DSTACK_AWS_SESSION_TOKEN\"\n    fi\n    \n    # Test AWS credentials before attempting ECR login\n    echo \"Testing AWS credentials...\"\n    if ! ./aws/dist/aws sts get-caller-identity &> /dev/null; then\n        echo \"AWS credentials test failed\"\n        # For session token credentials, this might be expected if they're expired\n        # Log warning but don't fail startup\n        if [[ -n \"$DSTACK_AWS_SESSION_TOKEN\" ]]; then\n            echo \"Warning: AWS temporary credentials may have expired, continuing startup\"\n            notify_host_hoot_info \"AWS temporary credentials may have expired\"\n        else\n            echo \"AWS credentials test failed\"\n            notify_host_hoot_error \"Invalid AWS credentials\"\n            exit 1\n        fi\n    else\n        echo \"Logging in to AWS ECR...\"\n        ./aws/dist/aws ecr get-login-password --region $DSTACK_AWS_REGION | docker login --username AWS --password-stdin \"$DSTACK_AWS_ECR_REGISTRY\"\n        if [ $? -eq 0 ]; then\n            echo \"AWS ECR login successful\"\n            notify_host_hoot_info \"AWS ECR login successful\"\n        else\n            echo \"AWS ECR login failed\"\n            # For session token credentials, don't fail startup if login fails\n            if [[ -n \"$DSTACK_AWS_SESSION_TOKEN\" ]]; then\n                echo \"Warning: AWS ECR login failed with temporary credentials, continuing startup\"\n                notify_host_hoot_info \"AWS ECR login failed with temporary credentials\"\n            else\n                notify_host_hoot_error \"AWS ECR login failed\"\n                exit 1\n            fi\n        fi\n    fi\nfi\n\nperform_cleanup\n\n#\n# Set root password.\n#\necho \"Setting root password..\"\n\n# Check if password files are writable\nPASSWD_WRITABLE=true\nif [ ! -w /etc/passwd ]; then\n    echo \"Warning: /etc/passwd is read-only\"\n    PASSWD_WRITABLE=false\nfi\nif [ ! -w /etc/shadow ]; then\n    echo \"Warning: /etc/shadow is read-only\"\n    PASSWD_WRITABLE=false\nfi\n\nif [ \"$PASSWD_WRITABLE\" = \"false\" ]; then\n    echo \"Skipping password setup due to read-only file system\"\nelse\n    # Check if chpasswd is available\n    if command -v chpasswd >/dev/null 2>&1; then\n        echo \"Using chpasswd method\"\n\n        if [ -n \"$DSTACK_ROOT_PASSWORD\" ]; then\n            echo \"Setting root password from user..\"\n            echo \"root:$DSTACK_ROOT_PASSWORD\" | chpasswd\n            unset DSTACK_ROOT_PASSWORD\n            echo \"Root password set/updated from DSTACK_ROOT_PASSWORD\"\n        elif [ -z \"$(grep '^root:' /etc/shadow 2>/dev/null | cut -d: -f2)\" ]; then\n            echo \"Setting random root password..\"\n            DSTACK_ROOT_PASSWORD=$(\n                LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | dd bs=1 count=32 2>/dev/null\n            )\n            echo \"root:$DSTACK_ROOT_PASSWORD\" | chpasswd\n            unset DSTACK_ROOT_PASSWORD\n            echo \"Root password set (random auto-init)\"\n        else\n            echo \"Root password already set; no changes.\"\n        fi\n    else\n        echo \"Using passwd method\"\n\n        if [ -n \"$DSTACK_ROOT_PASSWORD\" ]; then\n            echo \"Setting root password from user..\"\n            echo \"$DSTACK_ROOT_PASSWORD\" | passwd --stdin root 2>/dev/null \\\n                || printf '%s\\n%s\\n' \"$DSTACK_ROOT_PASSWORD\" \"$DSTACK_ROOT_PASSWORD\" | passwd root\n            unset DSTACK_ROOT_PASSWORD\n            echo \"Root password set/updated from DSTACK_ROOT_PASSWORD\"\n        elif [ -z \"$(grep '^root:' /etc/shadow 2>/dev/null | cut -d: -f2)\" ]; then\n            echo \"Setting random root password..\"\n            DSTACK_ROOT_PASSWORD=$(\n                LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | dd bs=1 count=32 2>/dev/null\n            )\n            echo \"$DSTACK_ROOT_PASSWORD\" | passwd --stdin root 2>/dev/null \\\n                || printf '%s\\n%s\\n' \"$DSTACK_ROOT_PASSWORD\" \"$DSTACK_ROOT_PASSWORD\" | passwd root\n            unset DSTACK_ROOT_PASSWORD\n            echo \"Root password set (random auto-init)\"\n        else\n            echo \"Root password already set; no changes.\"\n        fi\n    fi\nfi\n\n#\n# Set SSH authorized keys\n#\nif mkdir -p /home/root/.ssh 2>/dev/null; then\n    if [[ -n \"$DSTACK_ROOT_PUBLIC_KEY\" ]]; then\n        echo \"$DSTACK_ROOT_PUBLIC_KEY\" > /home/root/.ssh/authorized_keys\n        unset $DSTACK_ROOT_PUBLIC_KEY\n        echo \"Root public key set\"\n    fi\n    if [[ -n \"$DSTACK_AUTHORIZED_KEYS\" ]]; then\n        echo \"$DSTACK_AUTHORIZED_KEYS\" > /home/root/.ssh/authorized_keys\n        unset $DSTACK_AUTHORIZED_KEYS\n        echo \"Root authorized_keys set\"\n    fi\n\n    if [[ -f /dstack/user_config ]] && jq empty /dstack/user_config 2>/dev/null; then\n        if [[ $(jq 'has(\"ssh_authorized_keys\")' /dstack/user_config 2>/dev/null) == \"true\" ]]; then\n            jq -j '.ssh_authorized_keys' /dstack/user_config >> /home/root/.ssh/authorized_keys\n            # Remove duplicates if there are multiple keys\n            if [[ $(cat /home/root/.ssh/authorized_keys | wc -l) -gt 1 ]]; then\n                sort -u /home/root/.ssh/authorized_keys > /home/root/.ssh/authorized_keys.tmp\n                mv /home/root/.ssh/authorized_keys.tmp /home/root/.ssh/authorized_keys\n            fi\n            echo \"Set root authorized_keys from user preferences, total\" $(cat /home/root/.ssh/authorized_keys | wc -l) \"keys\"\n        fi\n    fi\nelse\n    echo \"Warning: Cannot create /home/root/.ssh directory (read-only file system?)\"\n    echo \"Skipping SSH key setup\"\nfi\n\nif [[ -S /var/run/dstack.sock ]]; then\n    export DSTACK_APP_ID=$(curl -s --unix-socket /var/run/dstack.sock http://dstack/Info | jq -j .app_id)\nelif [[ -S /var/run/tappd.sock ]]; then\n    export DSTACK_APP_ID=$(curl -s --unix-socket /var/run/tappd.sock http://dstack/prpc/Tappd.Info | jq -j .app_id)\nfi\n# Check if DSTACK_GATEWAY_DOMAIN is not set, try to get it from user_config or app-compose.json\n# Priority: user_config > app-compose.json\nif [[ -z \"$DSTACK_GATEWAY_DOMAIN\" ]]; then\n    # First try to get from /dstack/user_config if it exists and is valid JSON\n    if [[ -f /dstack/user_config ]] && jq empty /dstack/user_config 2>/dev/null; then\n        if [[ $(jq 'has(\"default_gateway_domain\")' /dstack/user_config 2>/dev/null) == \"true\" ]]; then\n            export DSTACK_GATEWAY_DOMAIN=$(jq -j '.default_gateway_domain' /dstack/user_config)\n        fi\n    fi\n\n    # If still not set, try to get from app-compose.json\n    if [[ -z \"$DSTACK_GATEWAY_DOMAIN\" ]] && [[ $(jq 'has(\"default_gateway_domain\")' app-compose.json) == \"true\" ]]; then\n        export DSTACK_GATEWAY_DOMAIN=$(jq -j '.default_gateway_domain' app-compose.json)\n    fi\nfi\nif [[ -n \"$DSTACK_GATEWAY_DOMAIN\" ]]; then\n    export DSTACK_APP_DOMAIN=$DSTACK_APP_ID\".\"$DSTACK_GATEWAY_DOMAIN\nfi\n\necho \"----------------------------------------------\"\necho \"Script execution completed\"\necho \"----------------------------------------------\"\n","public_logs":true,"public_sysinfo":true,"public_tcbinfo":true,"runner":"docker-compose","secure_time":false,"storage_fs":"zfs","tproxy_enabled":true}
